
//====================================================================================================================================================
// Copyright 2025 Lake Orion Robotics FIRST Team 302
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
// OR OTHER DEALINGS IN THE SOFTWARE.
//====================================================================================================================================================
// This file was automatically generated by the Team 302 code generator version 20.26.00.00
// Generated on Thursday, January 15, 2026 12:09:25 AM

#include <string>

// FRC Includes
#include <networktables/NetworkTableInstance.h>
#include <frc/Timer.h>

#include "BaseMechTesting.h"
#include "utils/logging/debug/Logger.h"
#include "utils/PeriodicLooper.h"
#include "state/RobotState.h"
#include "utils/DragonPower.h"

#include <ctre/phoenix/motorcontrol/can/TalonSRX.h>
#include <ctre/phoenix/motorcontrol/SupplyCurrentLimitConfiguration.h>
#include "rev/SparkMax.h"
#include "ctre/phoenix6/TalonFX.hpp"
#include "ctre/phoenix6/controls/Follower.hpp"
#include "ctre/phoenix6/configs/Configuration.hpp"
#include "ctre/phoenix6/TalonFXS.hpp"
#include "utils/logging/signals/DragonDataLogger.h"
#include <frc/DigitalInput.h>
#include <frc/filter/Debouncer.h>
#include <ctre/phoenix6/CANcoder.hpp>
#include <ctre/phoenix6/configs/Configurator.hpp>
#include <ctre/phoenix6/signals/SpnEnums.hpp>
#include "mechanisms/BaseMechTesting/OffState.h"
#include "mechanisms/BaseMechTesting/PercentOutState.h"
#include "mechanisms/BaseMechTesting/VelocityRPMState.h"
#include "mechanisms/BaseMechTesting/PositionInState.h"
#include "mechanisms/BaseMechTesting/PositionDegState.h"

using ctre::phoenix6::configs::Slot0Configs;
using ctre::phoenix6::configs::Slot1Configs;
using ctre::phoenix6::configs::TalonFXConfiguration;
using ctre::phoenix6::configs::TalonFXSConfiguration;
using ctre::phoenix6::signals::FeedbackSensorSourceValue;
using ctre::phoenix6::signals::ForwardLimitSourceValue;
using ctre::phoenix6::signals::ForwardLimitTypeValue;
using ctre::phoenix6::signals::GravityTypeValue;
using ctre::phoenix6::signals::InvertedValue;
using ctre::phoenix6::signals::MotorArrangementValue;
using ctre::phoenix6::signals::NeutralModeValue;
using ctre::phoenix6::signals::ReverseLimitSourceValue;
using ctre::phoenix6::signals::ReverseLimitTypeValue;
using ctre::phoenix6::signals::StaticFeedforwardSignValue;

using std::string;
using namespace BaseMechTestingStates;

void BaseMechTesting::CreateAndRegisterStates()
{
	OffState *OffStateInst = new OffState(string("Off"), 0, this, m_activeRobotId);
	AddToStateVector(OffStateInst);

	PercentOutState *PercentOutStateInst = new PercentOutState(string("PercentOut"), 1, this, m_activeRobotId);
	AddToStateVector(PercentOutStateInst);

	VelocityRPMState *VelocityRPMStateInst = new VelocityRPMState(string("VelocityRPM"), 2, this, m_activeRobotId);
	AddToStateVector(VelocityRPMStateInst);

	PositionInState *PositionInStateInst = new PositionInState(string("PositionIn"), 3, this, m_activeRobotId);
	AddToStateVector(PositionInStateInst);

	PositionDegState *PositionDegStateInst = new PositionDegState(string("PositionDeg"), 4, this, m_activeRobotId);
	AddToStateVector(PositionDegStateInst);

	OffStateInst->RegisterTransitionState(PercentOutStateInst);
	OffStateInst->RegisterTransitionState(VelocityRPMStateInst);
	OffStateInst->RegisterTransitionState(PositionInStateInst);
	OffStateInst->RegisterTransitionState(PositionDegStateInst);
	PercentOutStateInst->RegisterTransitionState(OffStateInst);
	PercentOutStateInst->RegisterTransitionState(VelocityRPMStateInst);
	PercentOutStateInst->RegisterTransitionState(PositionInStateInst);
	PercentOutStateInst->RegisterTransitionState(PositionDegStateInst);
	VelocityRPMStateInst->RegisterTransitionState(OffStateInst);
	VelocityRPMStateInst->RegisterTransitionState(PercentOutStateInst);
	VelocityRPMStateInst->RegisterTransitionState(PositionInStateInst);
	VelocityRPMStateInst->RegisterTransitionState(PositionDegStateInst);
	PositionInStateInst->RegisterTransitionState(OffStateInst);
	PositionInStateInst->RegisterTransitionState(PercentOutStateInst);
	PositionInStateInst->RegisterTransitionState(VelocityRPMStateInst);
	PositionInStateInst->RegisterTransitionState(PositionDegStateInst);
	PositionDegStateInst->RegisterTransitionState(OffStateInst);
	PositionDegStateInst->RegisterTransitionState(PercentOutStateInst);
	PositionDegStateInst->RegisterTransitionState(VelocityRPMStateInst);
	PositionDegStateInst->RegisterTransitionState(PositionInStateInst);
}

BaseMechTesting::BaseMechTesting(RobotIdentifier activeRobotId) : BaseMech(MechanismTypes::MECHANISM_TYPE::BASE_MECH_TESTING, std::string("BaseMechTesting")),
																  m_activeRobotId(activeRobotId),
																  m_stateMap()
{
	PeriodicLooper::GetInstance()->RegisterAll(this);
	// InitializeLogging();
}

/* void BaseMechTesting::InitializeLogging()
 {
	wpi::log::DataLog &log = frc::DataLogManager::GetLog();

	 m_BaseMechTestingTotalEnergyLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/BaseMechTesting/TotalEnergy");
m_BaseMechTestingTotalEnergyLogEntry.Append(0.0);
m_BaseMechTestingTotalWattHoursLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/BaseMechTesting/TotalWattHours");
m_BaseMechTestingTotalWattHoursLogEntry.Append(0.0);
m_TalonSRXTestLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/BaseMechTesting/TalonSRXTestPosition");
m_TalonSRXTestLogEntry.Append(0.0);
m_TalonSRXTestTargetLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/BaseMechTesting/TalonSRXTestTarget");
m_TalonSRXTestTargetLogEntry.Append(0.0);
m_TalonSRXTestPowerLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/BaseMechTesting/TalonSRXTestPower");
m_TalonSRXTestPowerLogEntry.Append(0.0);
m_TalonSRXTestEnergyLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/BaseMechTesting/TalonSRXTestEnergy");
m_TalonSRXTestEnergyLogEntry.Append(0.0);
m_SparkMaxBrushedTestLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/BaseMechTesting/SparkMaxBrushedTestPosition");
m_SparkMaxBrushedTestLogEntry.Append(0.0);
m_SparkMaxBrushedTestTargetLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/BaseMechTesting/SparkMaxBrushedTestTarget");
m_SparkMaxBrushedTestTargetLogEntry.Append(0.0);
m_SparkMaxBrushedTestPowerLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/BaseMechTesting/SparkMaxBrushedTestPower");
m_SparkMaxBrushedTestPowerLogEntry.Append(0.0);
m_SparkMaxBrushedTestEnergyLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/BaseMechTesting/SparkMaxBrushedTestEnergy");
m_SparkMaxBrushedTestEnergyLogEntry.Append(0.0);
m_TalonFXTestLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/BaseMechTesting/TalonFXTestPosition");
m_TalonFXTestLogEntry.Append(0.0);
m_TalonFXTestTargetLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/BaseMechTesting/TalonFXTestTarget");
m_TalonFXTestTargetLogEntry.Append(0.0);
m_TalonFXTestPowerLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/BaseMechTesting/TalonFXTestPower");
m_TalonFXTestPowerLogEntry.Append(0.0);
m_TalonFXTestEnergyLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/BaseMechTesting/TalonFXTestEnergy");
m_TalonFXTestEnergyLogEntry.Append(0.0);
m_TalonFXSTestLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/BaseMechTesting/TalonFXSTestPosition");
m_TalonFXSTestLogEntry.Append(0.0);
m_TalonFXSTestTargetLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/BaseMechTesting/TalonFXSTestTarget");
m_TalonFXSTestTargetLogEntry.Append(0.0);
m_TalonFXSTestPowerLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/BaseMechTesting/TalonFXSTestPower");
m_TalonFXSTestPowerLogEntry.Append(0.0);
m_TalonFXSTestEnergyLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/BaseMechTesting/TalonFXSTestEnergy");
m_TalonFXSTestEnergyLogEntry.Append(0.0);
m_digitalInputTestLogEntry = wpi::log::BooleanLogEntry(log, "mechanisms/BaseMechTesting/digitalInputTest");
m_digitalInputTestLogEntry.Append(false);

m_BaseMechTestingStateLogEntry = wpi::log::IntegerLogEntry(log, "mechanisms/BaseMechTesting/State");
m_BaseMechTestingStateLogEntry.Append(0);
 }*/

std::map<std::string, BaseMechTesting::STATE_NAMES>
	BaseMechTesting::stringToSTATE_NAMESEnumMap{
		{"STATE_OFF", BaseMechTesting::STATE_NAMES::STATE_OFF},
		{"STATE_PERCENT_OUT", BaseMechTesting::STATE_NAMES::STATE_PERCENT_OUT},
		{"STATE_VELOCITY_RPM", BaseMechTesting::STATE_NAMES::STATE_VELOCITY_RPM},
		{"STATE_POSITION_IN", BaseMechTesting::STATE_NAMES::STATE_POSITION_IN},
		{"STATE_POSITION_DEG", BaseMechTesting::STATE_NAMES::STATE_POSITION_DEG},
	};

void BaseMechTesting::CreateThing3()
{
	m_ntName = "BaseMechTesting";
	m_TalonSRXTest = new ctre::phoenix::motorcontrol::can::TalonSRX(8);
	m_SparkMaxBrushedTest = new rev::spark::SparkMax(13, rev::spark::SparkLowLevel::MotorType::kBrushless);
	m_TalonFXTest = new ctre::phoenix6::hardware::TalonFX(2, ctre::phoenix6::CANBus("canivore"));
	m_TalonFXSTest = new ctre::phoenix6::hardware::TalonFXS(0, ctre::phoenix6::CANBus("canivore"));

	m_DigitalInputTest = new frc::DigitalInput(0);
	m_DigitalInputTestIsInverted = false;

	ctre::phoenix6::configs::CANcoderConfiguration CANcoderTestConfigs{};
	CANcoderTestConfigs.MagnetSensor.MagnetOffset = units::angle::turn_t(0);
	CANcoderTestConfigs.MagnetSensor.SensorDirection = ctre::phoenix6::signals::SensorDirectionValue::CounterClockwise_Positive;
	m_CANcoderTest = new ctre::phoenix6::hardware::CANcoder(14, ctre::phoenix6::CANBus("canivore"));
	m_CANcoderTest->GetConfigurator().Apply(CANcoderTestConfigs);

	m_PercentOut = new ControlData(
		ControlModes::CONTROL_TYPE::PERCENT_OUTPUT,		  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_PercentOut",									  // std::string indentifier
		0,												  // double proportional
		0,												  // double integral
		0,												  // double derivative
		0,												  // double feedforward
		0,												  // double velocityGain
		0,												  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::VOLTAGE,					 // FEEDFORWARD_TYPE feedforwadType
		0,														 // double integralZone
		0,														 // double maxAcceleration
		0,														 // double cruiseVelocity
		0,														 // double peakValue
		0,														 // double nominalValue
		false,													 // bool enableFOC
		ControlData::GravityTypeValue::Elevator_Static,			 // Gravity type
		ControlData::StaticFeedforwardSignValue::UseVelocitySign // Static feedforward sign
	);
	m_FXVelocityRPM = new ControlData(
		ControlModes::CONTROL_TYPE::VELOCITY_REV_PER_SEC, // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_FXVelocityRPM",								  // std::string indentifier
		0.25,											  // double proportional
		0,												  // double integral
		0,												  // double derivative
		0.2,											  // double feedforward
		0,												  // double velocityGain
		0,												  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::VOLTAGE,					 // FEEDFORWARD_TYPE feedforwadType
		0,														 // double integralZone
		0,														 // double maxAcceleration
		0,														 // double cruiseVelocity
		0,														 // double peakValue
		0,														 // double nominalValue
		false,													 // bool enableFOC
		ControlData::GravityTypeValue::Elevator_Static,			 // Gravity type
		ControlData::StaticFeedforwardSignValue::UseVelocitySign // Static feedforward sign
	);
	m_FXSVelocityRPM = new ControlData(
		ControlModes::CONTROL_TYPE::VELOCITY_REV_PER_SEC, // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_FXSVelocityRPM",								  // std::string indentifier
		0.25,											  // double proportional
		0,												  // double integral
		0,												  // double derivative
		0.2,											  // double feedforward
		0,												  // double velocityGain
		0,												  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::VOLTAGE,					 // FEEDFORWARD_TYPE feedforwadType
		0,														 // double integralZone
		0,														 // double maxAcceleration
		0,														 // double cruiseVelocity
		0,														 // double peakValue
		0,														 // double nominalValue
		false,													 // bool enableFOC
		ControlData::GravityTypeValue::Elevator_Static,			 // Gravity type
		ControlData::StaticFeedforwardSignValue::UseVelocitySign // Static feedforward sign
	);
	m_FXPositionIn = new ControlData(
		ControlModes::CONTROL_TYPE::POSITION_INCH,		  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_FXPositionIn",								  // std::string indentifier
		0.1,											  // double proportional
		0,												  // double integral
		0,												  // double derivative
		0.2,											  // double feedforward
		0,												  // double velocityGain
		0,												  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::VOLTAGE,					 // FEEDFORWARD_TYPE feedforwadType
		0,														 // double integralZone
		0,														 // double maxAcceleration
		0,														 // double cruiseVelocity
		0,														 // double peakValue
		0,														 // double nominalValue
		true,													 // bool enableFOC
		ControlData::GravityTypeValue::Elevator_Static,			 // Gravity type
		ControlData::StaticFeedforwardSignValue::UseVelocitySign // Static feedforward sign
	);
	m_FXSPositionIn = new ControlData(
		ControlModes::CONTROL_TYPE::POSITION_INCH,		  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_FXSPositionIn",								  // std::string indentifier
		0.1,											  // double proportional
		0,												  // double integral
		0,												  // double derivative
		0.2,											  // double feedforward
		0,												  // double velocityGain
		0,												  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::VOLTAGE,					 // FEEDFORWARD_TYPE feedforwadType
		0,														 // double integralZone
		0,														 // double maxAcceleration
		0,														 // double cruiseVelocity
		0,														 // double peakValue
		0,														 // double nominalValue
		false,													 // bool enableFOC
		ControlData::GravityTypeValue::Elevator_Static,			 // Gravity type
		ControlData::StaticFeedforwardSignValue::UseVelocitySign // Static feedforward sign
	);
	m_FXPositionDeg = new ControlData(
		ControlModes::CONTROL_TYPE::POSITION_DEGREES,	  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_FXPositionDeg",								  // std::string indentifier
		0.15,											  // double proportional
		0,												  // double integral
		0,												  // double derivative
		0,												  // double feedforward
		0,												  // double velocityGain
		0,												  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::VOLTAGE,					   // FEEDFORWARD_TYPE feedforwadType
		0,														   // double integralZone
		0,														   // double maxAcceleration
		0,														   // double cruiseVelocity
		0,														   // double peakValue
		0,														   // double nominalValue
		false,													   // bool enableFOC
		ControlData::GravityTypeValue::Elevator_Static,			   // Gravity type
		ControlData::StaticFeedforwardSignValue::UseClosedLoopSign // Static feedforward sign
	);
	m_FXSPositionDeg = new ControlData(
		ControlModes::CONTROL_TYPE::POSITION_DEGREES,	  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_FXSPositionDeg",								  // std::string indentifier
		0.15,											  // double proportional
		0,												  // double integral
		0,												  // double derivative
		0,												  // double feedforward
		0,												  // double velocityGain
		0,												  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::VOLTAGE,					 // FEEDFORWARD_TYPE feedforwadType
		0,														 // double integralZone
		0,														 // double maxAcceleration
		0,														 // double cruiseVelocity
		0,														 // double peakValue
		0,														 // double nominalValue
		true,													 // bool enableFOC
		ControlData::GravityTypeValue::Elevator_Static,			 // Gravity type
		ControlData::StaticFeedforwardSignValue::UseVelocitySign // Static feedforward sign
	);

	ReadConstants("BaseMechTesting.xml", 3);
}

void BaseMechTesting::InitializeThing3()
{
	InitializeTalonSRXTalonSRXTestThing3();
	InitializeSparkMaxSparkMaxBrushedTestThing3();
	InitializeTalonFXTalonFXTestThing3();
	InitializeTalonFXSTalonFXSTestThing3();
}
void BaseMechTesting::InitializeTalonSRXTalonSRXTestThing3()
{
	m_TalonSRXTest->SetInverted(true);
	m_TalonSRXTest->EnableVoltageCompensation(true);
	m_TalonSRXTest->ConfigVoltageCompSaturation(10.0, 0);
	m_TalonSRXTest->SetNeutralMode(ctre::phoenix::motorcontrol::NeutralMode::Coast);
	m_TalonSRXTest->ConfigOpenloopRamp(0.25);
}

void BaseMechTesting::InitializeSparkMaxSparkMaxBrushedTestThing3()
{
	rev::spark::SparkBaseConfig SparkMaxBrushedTestConfig;
	SparkMaxBrushedTestConfig.Inverted(true);
	SparkMaxBrushedTestConfig.SetIdleMode(rev::spark::SparkBaseConfig::IdleMode::kCoast);
	SparkMaxBrushedTestConfig.SmartCurrentLimit(50);
	SparkMaxBrushedTestConfig.VoltageCompensation(10);
	SparkMaxBrushedTestConfig.OpenLoopRampRate(0.25);
	SparkMaxBrushedTestConfig.ClosedLoopRampRate(0.25);
	SparkMaxBrushedTestConfig.limitSwitch.ForwardLimitSwitchEnabled(false);
	SparkMaxBrushedTestConfig.limitSwitch.ReverseLimitSwitchEnabled(false);
	m_SparkMaxBrushedTest->Configure(SparkMaxBrushedTestConfig, rev::spark::SparkBase::ResetMode::kResetSafeParameters, rev::spark::SparkBase::PersistMode::kPersistParameters);
}

void BaseMechTesting::InitializeTalonFXTalonFXTestThing3()
{
	TalonFXConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(100);
	configs.CurrentLimits.StatorCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(60);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(40);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.OpenLoopRamps.VoltageOpenLoopRampPeriod = units::time::second_t(0.25);

	configs.HardwareLimitSwitch.ForwardLimitEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::CounterClockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Coast;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	configs.MotionMagic.MotionMagicCruiseVelocity = units::angular_velocity::turns_per_second_t(5);
	configs.MotionMagic.MotionMagicAcceleration = units::angular_acceleration::radians_per_second_squared_t(1);
	configs.MotionMagic.MotionMagicJerk = units::angular_jerk::radians_per_second_cubed_t(0);

	configs.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue::RotorSensor;
	configs.Feedback.SensorToMechanismRatio = 1;

	configs.Slot0.kI = m_FXVelocityRPM->GetI();
	configs.Slot0.kD = m_FXVelocityRPM->GetD();
	configs.Slot0.kG = m_FXVelocityRPM->GetF();
	configs.Slot0.kS = m_FXVelocityRPM->GetS();
	configs.Slot0.kV = m_FXVelocityRPM->GetV();
	configs.Slot0.kP = m_FXVelocityRPM->GetP();
	configs.Slot0.kA = m_FXVelocityRPM->GetA();
	configs.Slot0.GravityType = m_FXVelocityRPM->GetGravityType();
	configs.Slot0.StaticFeedforwardSign = m_FXVelocityRPM->GetStaticFeedforwardSign();

	configs.Slot1.kI = m_FXPositionIn->GetI();
	configs.Slot1.kD = m_FXPositionIn->GetD();
	configs.Slot1.kG = m_FXPositionIn->GetF();
	configs.Slot1.kS = m_FXPositionIn->GetS();
	configs.Slot1.kV = m_FXPositionIn->GetV();
	configs.Slot1.kP = m_FXPositionIn->GetP();
	configs.Slot1.kA = m_FXPositionIn->GetA();
	configs.Slot1.GravityType = m_FXPositionIn->GetGravityType();
	configs.Slot1.StaticFeedforwardSign = m_FXPositionIn->GetStaticFeedforwardSign();

	configs.Slot2.kI = m_FXPositionDeg->GetI();
	configs.Slot2.kD = m_FXPositionDeg->GetD();
	configs.Slot2.kG = m_FXPositionDeg->GetF();
	configs.Slot2.kS = m_FXPositionDeg->GetS();
	configs.Slot2.kV = m_FXPositionDeg->GetV();
	configs.Slot2.kP = m_FXPositionDeg->GetP();
	configs.Slot2.kA = m_FXPositionDeg->GetA();
	configs.Slot2.GravityType = m_FXPositionDeg->GetGravityType();
	configs.Slot2.StaticFeedforwardSign = m_FXPositionDeg->GetStaticFeedforwardSign();

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_TalonFXTest->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_TalonFXTest", "m_TalonFXTest Status", status.GetName());

	m_TalonFXTestFXPositionDeg.EnableFOC = m_FXPositionDeg->IsFOCEnabled();
}

void BaseMechTesting::InitializeTalonFXSTalonFXSTestThing3()
{
	TalonFXSConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(60);
	configs.CurrentLimits.StatorCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(40);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(35);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.ClosedLoopRamps.TorqueClosedLoopRampPeriod = units::time::second_t(0.25);

	configs.HardwareLimitSwitch.ForwardLimitEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::CounterClockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Coast;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	configs.Commutation.MotorArrangement = MotorArrangementValue::Disabled;

	configs.Slot0.kI = m_FXSVelocityRPM->GetI();
	configs.Slot0.kD = m_FXSVelocityRPM->GetD();
	configs.Slot0.kG = m_FXSVelocityRPM->GetF();
	configs.Slot0.kS = m_FXSVelocityRPM->GetS();
	configs.Slot0.kV = m_FXSVelocityRPM->GetV();
	configs.Slot0.kP = m_FXSVelocityRPM->GetP();
	configs.Slot0.kA = m_FXSVelocityRPM->GetA();
	configs.Slot0.GravityType = m_FXSVelocityRPM->GetGravityType();
	configs.Slot0.StaticFeedforwardSign = m_FXSVelocityRPM->GetStaticFeedforwardSign();

	configs.Slot1.kI = m_FXSPositionIn->GetI();
	configs.Slot1.kD = m_FXSPositionIn->GetD();
	configs.Slot1.kG = m_FXSPositionIn->GetF();
	configs.Slot1.kS = m_FXSPositionIn->GetS();
	configs.Slot1.kV = m_FXSPositionIn->GetV();
	configs.Slot1.kP = m_FXSPositionIn->GetP();
	configs.Slot1.kA = m_FXSPositionIn->GetA();
	configs.Slot1.GravityType = m_FXSPositionIn->GetGravityType();
	configs.Slot1.StaticFeedforwardSign = m_FXSPositionIn->GetStaticFeedforwardSign();

	configs.Slot2.kI = m_FXSPositionDeg->GetI();
	configs.Slot2.kD = m_FXSPositionDeg->GetD();
	configs.Slot2.kG = m_FXSPositionDeg->GetF();
	configs.Slot2.kS = m_FXSPositionDeg->GetS();
	configs.Slot2.kV = m_FXSPositionDeg->GetV();
	configs.Slot2.kP = m_FXSPositionDeg->GetP();
	configs.Slot2.kA = m_FXSPositionDeg->GetA();
	configs.Slot2.GravityType = m_FXSPositionDeg->GetGravityType();
	configs.Slot2.StaticFeedforwardSign = m_FXSPositionDeg->GetStaticFeedforwardSign();

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_TalonFXSTest->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_TalonFXSTest", "m_TalonFXSTest Status", status.GetName());
}

void BaseMechTesting::SetCurrentState(int state, bool run)
{
	StateMgr::SetCurrentState(state, run);
}

void BaseMechTesting::RunCommonTasks()
{
	// This function is called once per loop before the current state Run()
	Cyclic();
}

/// @brief  Set the control constants (e.g. PIDF values).
/// @param [in] ControlData*                                   pid:  the control constants
/// @return void
void BaseMechTesting::SetControlConstants(RobotElementNames::MOTOR_CONTROLLER_USAGE identifier, int slot, ControlData pid)
{
}

/// @brief update the output to the mechanism using the current controller and target value(s)
/// @return void
void BaseMechTesting::Update()
{
	m_TalonSRXTest->Set(ctre::phoenix::motorcontrol::TalonSRXControlMode::PercentOutput, m_TalonSRXTestActiveTarget);

	m_TalonFXTest->SetControl(*m_TalonFXTestActiveTarget);
	m_TalonFXSTest->SetControl(*m_TalonFXSTestActiveTarget);
}

bool BaseMechTesting::IsAtMinPosition(RobotElementNames::MOTOR_CONTROLLER_USAGE identifier) const
{
	// auto motor = GetMotorMech(identifier);
	// if (motor != nullptr)
	// {
	//     return motor->IsAtMinTravel();
	// }
	return false;
}

bool BaseMechTesting::IsAtMaxPosition(RobotElementNames::MOTOR_CONTROLLER_USAGE identifier) const
{
	// auto motor = GetMotorMech(identifier);
	// if (motor != nullptr)
	// {
	//     return motor->IsAtMaxTravel();
	// }
	return false;
}

void BaseMechTesting::Cyclic()
{
	Update();

	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "BaseMechTesting", "TalonSRXTest Position", m_TalonSRXTest->GetSelectedSensorPosition());
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "BaseMechTesting", "SparkMaxBrushedTest Position", m_SparkMaxBrushedTest->GetEncoder().GetPosition());
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "BaseMechTesting", "TalonFXTest Position", m_TalonFXTest->GetPosition().GetValueAsDouble());
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "BaseMechTesting", "TalonFXTest Velocity", m_TalonFXTest->GetVelocity().GetValueAsDouble());
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "BaseMechTesting", "TalonFXSTest Position", m_TalonFXSTest->GetPosition().GetValueAsDouble());
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "BaseMechTesting", "TalonFXSTest Velocity", m_TalonFXSTest->GetVelocity().GetValueAsDouble());
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "BaseMechTesting", "CANcoderTest Position", m_CANcoderTest->GetPosition().GetValueAsDouble());
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "BaseMechTesting", "DigitalInputTest Value", GetdigitalInputTestState());
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "BaseMechTesting", "Current State", GetCurrentState());
}

ControlData *BaseMechTesting::GetControlData(string name)
{
	if (name.compare("PercentOut") == 0)
		return m_PercentOut;
	if (name.compare("FXVelocityRPM") == 0)
		return m_FXVelocityRPM;
	if (name.compare("FXSVelocityRPM") == 0)
		return m_FXSVelocityRPM;
	if (name.compare("FXPositionIn") == 0)
		return m_FXPositionIn;
	if (name.compare("FXSPositionIn") == 0)
		return m_FXSPositionIn;
	if (name.compare("FXPositionDeg") == 0)
		return m_FXPositionDeg;
	if (name.compare("FXSPositionDeg") == 0)
		return m_FXSPositionDeg;

	return nullptr;
}

/* void BaseMechTesting::DataLog(uint64_t timestamp)
{
   auto currTime = m_powerTimer.Get();
LogTalonSRXTest(timestamp, m_TalonSRXTest->GetPosition().GetValueAsDouble());
auto TalonSRXTestPower = DragonPower::CalcPowerEnergy(currTime, m_TalonSRXTest->GetSupplyVoltage().GetValueAsDouble(), m_TalonSRXTest->GetSupplyCurrent().GetValueAsDouble());
m_power = get<0>(TalonSRXTestPower);
m_energy = get<1>(TalonSRXTestPower);
m_totalEnergy += m_energy;
LogTalonSRXTestPower(timestamp, m_power);
LogTalonSRXTestEnergy(timestamp, m_energy);
LogSparkMaxBrushedTest(timestamp, m_SparkMaxBrushedTest->GetPosition().GetValueAsDouble());
auto SparkMaxBrushedTestPower = DragonPower::CalcPowerEnergy(currTime, m_SparkMaxBrushedTest->GetSupplyVoltage().GetValueAsDouble(), m_SparkMaxBrushedTest->GetSupplyCurrent().GetValueAsDouble());
m_power = get<0>(SparkMaxBrushedTestPower);
m_energy = get<1>(SparkMaxBrushedTestPower);
m_totalEnergy += m_energy;
LogSparkMaxBrushedTestPower(timestamp, m_power);
LogSparkMaxBrushedTestEnergy(timestamp, m_energy);
LogTalonFXTest(timestamp, m_TalonFXTest->GetPosition().GetValueAsDouble());
auto TalonFXTestPower = DragonPower::CalcPowerEnergy(currTime, m_TalonFXTest->GetSupplyVoltage().GetValueAsDouble(), m_TalonFXTest->GetSupplyCurrent().GetValueAsDouble());
m_power = get<0>(TalonFXTestPower);
m_energy = get<1>(TalonFXTestPower);
m_totalEnergy += m_energy;
LogTalonFXTestPower(timestamp, m_power);
LogTalonFXTestEnergy(timestamp, m_energy);
LogTalonFXSTest(timestamp, m_TalonFXSTest->GetPosition().GetValueAsDouble());
auto TalonFXSTestPower = DragonPower::CalcPowerEnergy(currTime, m_TalonFXSTest->GetSupplyVoltage().GetValueAsDouble(), m_TalonFXSTest->GetSupplyCurrent().GetValueAsDouble());
m_power = get<0>(TalonFXSTestPower);
m_energy = get<1>(TalonFXSTestPower);
m_totalEnergy += m_energy;
LogTalonFXSTestPower(timestamp, m_power);
LogTalonFXSTestEnergy(timestamp, m_energy);
LogdigitalInputTest(timestamp, GetdigitalInputTest());
LogBaseMechTestingState(timestamp, GetCurrentState());
m_totalWattHours += DragonPower::ConvertEnergyToWattHours(m_totalEnergy);
LogBaseMechTestingTotalEnergy(timestamp, m_totalEnergy);
LogBaseMechTestingTotalWattHours(timestamp, m_totalWattHours);
m_powerTimer.Reset();
m_powerTimer.Start();
 }*/